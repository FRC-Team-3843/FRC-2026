================================================================================
FRC Team 3843 - 2026 Robot "Field Manual"
================================================================================

This document is the AUTHORITATIVE guide for the 2026 Robot Code.
It covers Setup, Configuration, Tuning, and Troubleshooting in EXTREME detail.

DO NOT GUESS. FOLLOW THESE INSTRUCTIONS EXACTLY.

================================================================================
SECTION 1: THE "BEVEL GEAR" RULE & MODULE ZEROING (CRITICAL)
================================================================================

One of the most common failures in Swerve drive setup is ambiguous wheel alignment.
"Facing Forward" is not enough because the wheel is symmetric, but the GEARBOX IS NOT.

### The Ambiguity
A swerve module wheel can face "Forward" in two ways:
1.  Wheel forward, Bevel Gear on the LEFT.
2.  Wheel forward, Bevel Gear on the RIGHT.

If you are inconsistent (e.g., FL has bevel left, FR has bevel right), your drive 
motors will fight each other, or one side will drive backwards when commanded forward.

### The 2026 Standard Configuration
The code in `src/main/deploy/swerve/modules/*.json` currently has:
`"inverted": { "drive": false }` for ALL modules.

This implies a **UNIFORM CONFIGURATION**.

**MANDATORY CHECK:**
Look at your physical robot modules.
1.  Point all wheels "Straight Forward" (parallel to the side rails).
2.  Look at the Bevel Gear (the metal gear touching the wheel).
3.  **ARE THEY ALL ON THE SAME SIDE?** (e.g., All on the Left of the wheel?)

**Scenario A: All Bevels are on the LEFT (Standard)**
-   This matches `inverted.drive: false` for MK4/MK4i L1/L2.
-   Proceed to calibration.

**Scenario B: All Bevels are on the RIGHT**
-   You must change `inverted.drive` to `true` in ALL four module JSON files.
-   `src/main/deploy/swerve/modules/frontleft.json`, etc.

**Scenario C: Modules are Mirrored (e.g., Fronts are Left, Backs are Right)**
-   This is common in tight chassis designs.
-   You MUST configure each module individually.
-   Modules with Bevel Left -> `inverted.drive: false`
-   Modules with Bevel Right -> `inverted.drive: true`

### Precise Zeroing Procedure (The "Jig" Method)
Do not just "eyeball" it.
1.  **Elevate the Robot.**
2.  **Align the Wheels:**
    -   Use a long straight edge (piece of 1x2 or angle aluminum).
    -   Press it flat against the side frame rail.
    -   Rotate the FL and BL modules so their forks/wheels are perfectly flush with the straight edge.
    -   **CRITICAL:** Ensure the Bevel Gears are facing the correct "Standard" direction (usually LEFT) as determined above. Do not align them 180 degrees off!
3.  **Check CANCoder Values:**
    -   Open Phoenix Tuner X.
    -   Record the "Absolute Position" (degrees).
    -   Update `absoluteEncoderOffset` in the corresponding JSON file.
4.  **Repeat for Right Side.**

================================================================================
SECTION 2: YAGSL CONFIGURATION DEEP DIVE
================================================================================

YAGSL uses a specific coordinate system and unit convention.

### 2.1 Module Locations (Center-to-Center)
In `frontleft.json`, `location` is in **INCHES** (because `physicalproperties.json` uses inches for wheel diameter).
-   `front`: Distance from robot CENTER to module center (X axis). Positive = Forward.
-   `left`: Distance from robot CENTER to module center (Y axis). Positive = Left.

**Example for 27" x 27" Frame:**
If the modules are in the corners, the center-to-center distance is usually Frame Size minus Module Inset.
-   Standard MK4 inset is ~2.625".
-   27" - (2.625 * 2) = 21.75" wheelbase.
-   Half of that (Center to Module) = 10.875".
-   **Verify `location` values in JSONs match YOUR robot's actual geometry.**
    -   If your JSON says `13.5` (which implies a 27" wheelbase, meaning 32" frame), but you have a 27" frame, YOUR ODOMETRY WILL BE WRONG.
    -   **ACTION:** Measure center-to-center distance between FL and FR wheels. Divide by 2. This is your `left` value. Measure FL to BL. Divide by 2. This is your `front` value.

### 2.2 PID Tuning (pidfproperties.json)
The default values are generic placeholders.
-   `drive.p`: Controls velocity error. Too low = sluggish. Too high = stuttering.
-   `angle.p`: Controls steering error. Too low = lazy steering. Too high = violent shaking/oscillation.

**Tuning Workflow:**
1.  Set `drive.p` to 0.002 (conservative).
2.  Set `angle.p` to 0.01 (conservative).
3.  **Run SysId** (see below) to get perfect values.
4.  If not using SysId:
    -   Increase `angle.p` until the module oscillates (shakes) when standing still, then cut it in half.
    -   Increase `drive.p` until the robot hits target speed instantly without overshooting.

================================================================================
SECTION 3: PHOTONVISION SETUP & COORDINATE SYSTEMS
================================================================================

Vision is useless if calibrated wrong.

### 3.1 Camera Positioning (The "Origin" Rule)
You must measure the camera's position relative to the **ROBOT CENTER** (on the floor).
-   **X:** +Forward (Camera in front of center = positive).
-   **Y:** +Left (Camera left of center = positive).
-   **Z:** +Up (Height from carpet to lens center).
-   **Roll:** Rotation around X axis (0 if level).
-   **Pitch:** Rotation around Y axis (Positive = Up, Negative = Down).
-   **Yaw:** Rotation around Z axis (0 = Facing Forward, +90 = Left).

**Configuration:**
1.  Go to `src/main/java/frc/robot/subsystems/swervedrive/Vision.java`.
2.  Find the `Cameras` enum.
3.  Update the `Translation3d` and `Rotation3d` parameters.
    -   `Rotation3d(roll, pitch, yaw)` in RADIANS.
    -   Use `Math.toRadians(degrees)` for clarity.

### 3.2 2026 vs 2025 Field Layout
The current code loads `AprilTagFields.k2025ReefscapeAndyMark`.
-   **Action:** When WPILib 2026.2.x or later is released with 2026 field data, change this to `k2026...`.
-   **Impact:** If you run this on a 2026 field with the 2025 layout loaded, the robot will think it is in a completely different location (or off the field) because tag IDs and locations change every year.

### 3.3 Noise & Standard Deviations
The `Vision.java` file contains logic to trust/distrust vision data:
-   `singleTagStdDevs`: Uncertainty when only 1 tag is visible.
-   `multiTagStdDevs`: Uncertainty when 2+ tags are visible (MUCH safer).

**Tuning:**
If the robot "teleports" or twitches when it sees a tag:
-   INCREASE the standard deviations (tell the code "Vision is noisy, trust odometry more").
-   Example: Change `VecBuilder.fill(4, 4, 8)` to `VecBuilder.fill(6, 6, 10)`.

================================================================================
SECTION 4: STARTUP & ZEROING PROCEDURE (STEP-BY-STEP)
================================================================================

### Step 1: Physical "Safe Mode"
1.  Put robot on blocks. Wheels must spin freely.
2.  Power ON.
3.  Open Driver Station.
4.  Check for CAN Errors (must be 0%).

### Step 2: Verification of "Forward"
1.  Deploy code.
2.  Open **AdvantageScope** or **SmartDashboard**.
3.  Look at the "Swerve States" or "Module Angles".
4.  Physically rotate the FL module to be straight forward (Bevel Left).
    -   Does the dashboard read 0 degrees (or close to 0)?
    -   If it reads ~180, your offset is flipped.
    -   If it reads random numbers, you need to Calibrate.

### Step 3: The "Spin Test" (Verifying Drive Inversion)
1.  Enable Robot (Teleop).
2.  Gently push joystick **FORWARD**.
3.  **WATCH THE WHEELS.**
    -   Do they spin to push the robot Forward? -> GOOD.
    -   Do they spin backward? -> BAD. Set `inverted.drive: true` in JSON.
    -   Does one spin back and one spin forward? -> BAD. Check Bevel Orientation consistency (See Section 1).

### Step 4: The "Steer Test" (Verifying Angle Inversion)
1.  Gently rotate joystick (turning command).
2.  **WATCH THE MODULES.**
    -   Stick Left -> Modules should rotate CCW (viewed from top).
    -   Stick Right -> Modules should rotate CW.
    -   If inverted: Set `inverted.angle: true` in JSON. (Rare for MK4i).

### Step 5: Gyro Zeroing
1.  Place robot on ground.
2.  Align robot to face AWAY from driver station.
3.  Press "Start" (configured zero button).
4.  Push stick forward. Robot should drive away.

================================================================================
SECTION 5: PATHPLANNER AUTONOMOUS CHECKLIST
================================================================================

1.  **Robot Size:** Open `src/main/deploy/pathplanner/settings.json`. Ensure `robotWidth` and `robotLength` match your frame + bumpers.
2.  **Constraints:** `defaultMaxVel` and `defaultMaxAccel` must be attainable. If set to 5 m/s but robot only goes 3.7 m/s, paths will fail.
3.  **PID:** `Constants.AutonConstants` control path accuracy.
    -   If robot wanders off path: Increase `TRANSLATION_P`.
    -   If robot oscillates (fishtails) on path: Decrease `TRANSLATION_P`.

================================================================================
SECTION 6: SYSID (SYSTEM IDENTIFICATION)
================================================================================

Do not skip this. Default PIDs are guesses.
1.  Deploy code.
2.  Driver Station -> Test Mode.
3.  **Drive Characterization:**
    -   Clear space (15ft+).
    -   Hold 'X'. Robot drives ramp/step tests.
    -   Release 'X' when done.
4.  **Angle Characterization:**
    -   Hold 'Y'. Modules rotate.
5.  **Analysis:**
    -   Use WPILib SysId tool.
    -   Load the `.wpilog` file generated on the RIO.
    -   Calculate `kV`, `kA`, `kP`.
    -   Put these values into `pidfproperties.json`.

================================================================================
END OF FIELD MANUAL
================================================================================